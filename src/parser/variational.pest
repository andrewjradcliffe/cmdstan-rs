// Declaration of a sum type, with CmdStan's rule two declarations without a body
// must not be adjacent
variational_algorithm = {
    !("algorithm" ~ ((" ")+ ~ "algorithm" ~ &(" "))+)
    ~ ("algorithm" ~ ("=" ~ (meanfield | fullrank)))
}
variational_algorithm_as_type = { SOI ~ variational_algorithm ~ &EOI }

meanfield = { "meanfield" }
fullrank = { "fullrank" }

// Declaration of a product type, with CmdStan's rule that
// declarations of the same product type, with or without a body, must not be adjacent
variational_adapt = {
    !( ("adapt" ~ ((" ")+ ~ variational_adapt_pair)*)
        ~ ((" ")+ ~ ("adapt" ~ ((" ")+ ~ variational_adapt_pair)*))+
    )
    ~
    ("adapt" ~ ((" ")+ ~ variational_adapt_pair)*)
}
variational_adapt_as_type = { SOI ~ variational_adapt ~ &EOI }


variational_adapt_pair = {
    engaged
  | iter
}

// Two or more of the same field, directly adjacent and without a
// value, is an error.
grad_samples       = ${
    !(("grad_samples" ~ ((" ")+ ~ "grad_samples" ~ (&(" ") | EOI))+))
    ~ "grad_samples" ~ ("=" ~ integer)?
}
elbo_samples       = ${
    !(("elbo_samples" ~ ((" ")+ ~ "elbo_samples" ~ (&(" ") | EOI))+))
    ~ "elbo_samples" ~ ("=" ~ integer)?
}
eta       = ${
    !(("eta" ~ ((" ")+ ~ "eta" ~ (&(" ") | EOI))+))
    ~ "eta" ~ ("=" ~ float)?
}
eval_elbo       = ${
    !(("eval_elbo" ~ ((" ")+ ~ "eval_elbo" ~ (&(" ") | EOI))+))
    ~ "eval_elbo" ~ ("=" ~ integer)?
}
output_samples       = ${
    !(("output_samples" ~ ((" ")+ ~ "output_samples" ~ (&(" ") | EOI))+))
    ~ "output_samples" ~ ("=" ~ integer)?
}

// Body of a sum type, non-unit variant
variational = { "variational" ~ ((" ")+ ~ variational_term)* }

variational_term = { variational_algorithm
    | iter
    | grad_samples
    | elbo_samples
    | eta
    | variational_adapt
    | tol_rel_obj
    | eval_elbo
    | output_samples
}

